1. Overview of Object Oriented Programming


    1.1 Data Types: Overview, Types, Type Conversion

        -> Data Types – Overview
            In programming, data types define the kind of data that can be stored and manipulated in a program.
            They tell the compiler or interpreter how much memory to allocate and which operations can be performed on that data.

            Key Points:
                - Every variable must have a data type.
                - Data types decide the range of values (e.g., int stores numbers, char stores characters).
                - Helps the program to be memory efficient and error-free.

            Example (Real Life Analogy):
                Think of data types as containers:
                - A water bottle can only hold water (like int can only hold integers).
                - A lunch box can hold food (like string can hold characters).
                - You can’t put a pizza into a pencil box (wrong data type error).

        -> Types of Data Types

            (A) Primitive / Fundamental Data Types
                These are the basic building blocks provided by most programming languages.

                | Data Type | Size (in Java/C) | Example      | Usage                           |
                | --------- | ---------------- | ------------ | ------------------------------- |
                | `int`     | 4 bytes          | 10, -25      | Counting, IDs                   |
                | `float`   | 4 bytes          | 3.14, -9.8   | Decimal values (less precision) |
                | `double`  | 8 bytes          | 45.67891     | High precision decimals         |
                | `char`    | 2 bytes (Java)   | 'A', 'z'     | Storing a character             |
                | `boolean` | 1 bit            | true / false | Conditions (yes/no)             |
                | `byte`    | 1 byte           | 120          | Storing small numbers           |
                | `short`   | 2 bytes          | 1500         | Medium range numbers            |
                | `long`    | 8 bytes          | 1234567890   | Very large numbers              |

                Example (Java):
                    int age = 21;
                    float price = 99.50f;
                    char grade = 'A';
                    boolean isPass = true;

            (B) Derived Data Types
                Built from primitive types.

                Examples:
                    - Arrays → store multiple values of same type.
                    - Strings → sequence of characters.
                    - Pointers (in C) → store address of variables.

                Example:
                    int marks[] = {85, 90, 75};   // Array
                    String name = "Vinit";        // String

            (C) User-defined Data Types
                Defined by the programmer.

                Examples: 
                    class, structure, enum, union.

                Example (Java Class):
                    class Student {
                        int id;
                        String name;
                    }

        -> Type Conversion
            Type conversion means changing one data type into another.
            It is necessary when you want to perform operations between different data types.

            (A) Implicit Type Conversion (Type Casting / Type Promotion)
                Also called Type Promotion or Type Casting by Compiler.
                Happens automatically when a smaller data type is converted into a larger data type.

                Rules:
                    - No data loss.
                    - Done by compiler.

                    - Example: int → float → double.

                Example (Java):
                    int a = 10;
                    double b = a;   // int is automatically converted to double
                    System.out.println(b);  // Output: 10.0
                
                Real Life Analogy:
                    Think of putting a small cup of tea into a big mug. It will easily fit without spilling (safe conversion).

            (B) Explicit Type Conversion (Type Casting by User)
                Also called Type Casting.
                When programmer manually converts one type into another using cast operator (type).

                Syntax:
                    datatype variable = (datatype) value;

                Example (Java):
                    double price = 99.99;
                    int finalPrice = (int) price;  // Decimal part is removed
                    System.out.println(finalPrice);  // Output: 99

                Real Life Analogy:
                    Like pouring a big jug of water into a small glass – some part will overflow (loss of data).

                Example Combining Both
                    public class TypeCastingExample {
                        public static void main(String[] args) {
                            int x = 5;
                            double y = x;     // Implicit Conversion
                            System.out.println("Implicit: " + y);

                            double p = 9.78;
                            int q = (int) p;  // Explicit Conversion
                            System.out.println("Explicit: " + q);
                        }
                    }

                Output:
                    Implicit: 5.0
                    Explicit: 9

        -> Summary Table

            | Conversion Type | Who Does It? | Data Loss | Example        |
            | --------------- | ------------ | --------- | -------------- |
            | Implicit        | Compiler     | No        | `int → double` |
            | Explicit        | Programmer   | Possible  | `double → int` |

        -> Real-Life Example (Banking System)

            Imagine a banking software:
                - int for storing account number.
                - double for storing balance.
                - String for customer name.
                - boolean for loan status (approved/not approved).

            Code Example:
                public class Bank {
                    public static void main(String[] args) {
                        int accountNo = 12345;
                        String name = "Vinit Bawjee";
                        double balance = 10500.75;
                        boolean hasLoan = false;

                        // Implicit conversion
                        double newBalance = accountNo; // int → double

                        // Explicit conversion
                        int approxBalance = (int) balance; // double → int

                        System.out.println("Account: " + accountNo);
                        System.out.println("Name: " + name);
                        System.out.println("Balance: " + balance);
                        System.out.println("Approx Balance (int): " + approxBalance);
                        System.out.println("Loan Approved: " + hasLoan);
                    }
                }


    1.2 Operators: Types, Precedence, and Associativity, Expression Evaluation

        -> Operators – Overview
            Operators are symbols that tell the compiler to perform specific operations on data.
            They act as tools to manipulate variables and values.

            Real-Life Analogy:

                Think of operators as tools in a toolbox:
                    - + is like a calculator’s addition button.
                    - == is like asking “Are these two things equal?”.
                    - && is like saying “Do both conditions pass?”.

        -> Types of Operators

            (A) Arithmetic Operators
                Used for mathematical calculations.

                | Operator | Meaning             | Example  | Result |
                | -------- | ------------------- | -------- | ------ |
                | `+`      | Addition            | `5 + 3`  | 8      |
                | `-`      | Subtraction         | `10 - 4` | 6      |
                | `*`      | Multiplication      | `6 * 2`  | 12     |
                | `/`      | Division (quotient) | `9 / 2`  | 4      |
                | `%`      | Modulus (remainder) | `9 % 2`  | 1      |

                Example (Java):
                    int a = 9, b = 2;
                    System.out.println(a / b);  // 4
                    System.out.println(a % b);  // 1

            (B) Relational Operators
                Used to compare values. Result is always true or false.

                | Operator | Meaning          | Example  | Result |
                | -------- | ---------------- | -------- | ------ |
                | `==`     | Equal to         | `5 == 5` | true   |
                | `!=`     | Not equal to     | `5 != 3` | true   |
                | `>`      | Greater than     | `10 > 2` | true   |
                | `<`      | Less than        | `5 < 2`  | false  |
                | `>=`     | Greater or equal | `5 >= 5` | true   |
                | `<=`     | Less or equal    | `3 <= 5` | true   |

            (C) Logical Operators
                Used with boolean values.

                | Operator | Meaning     | Example             | Result     |          |   |           |      |
                | -------- | ----------- | ------------------- | ---------- | -------- | - | --------- | ---- |
                | `&&`     | Logical AND | `(5 > 2 && 10 > 5)` | true       |          |   |           |      |
                | \`       |             | \`                  | Logical OR | \`(5 > 2 |   | 2 > 10)\` | true |
                | `!`      | Logical NOT | `!(5 > 2)`          | false      |          |   |           |      |

                Real Life Example:
                    - AND (&&): “I will go out if it is sunny AND I have free time.”
                    - OR (||): “I will watch TV if it is raining OR I am bored.”

            (D) Assignment Operators
                Used to assign values to variables.

                | Operator | Meaning           | Example  | Equivalent To |
                | -------- | ----------------- | -------- | ------------- |
                | `=`      | Assign            | `x = 5`  | x = 5         |
                | `+=`     | Add & assign      | `x += 3` | x = x + 3     |
                | `-=`     | Subtract & assign | `x -= 2` | x = x - 2     |
                | `*=`     | Multiply & assign | `x *= 4` | x = x \* 4    |
                | `/=`     | Divide & assign   | `x /= 2` | x = x / 2     |
                | `%=`     | Modulus & assign  | `x %= 2` | x = x % 2     |

            (E) Unary Operators
                Work on a single operand.

                | Operator | Meaning                | Example |
                | -------- | ---------------------- | ------- |
                | `++`     | Increment by 1         | `x++`   |
                | `--`     | Decrement by 1         | `x--`   |
                | `+`      | Unary plus (no change) | `+x`    |
                | `-`      | Unary minus (negation) | `-x`    |

                Pre-increment vs Post-increment:
                    int x = 5;
                    System.out.println(++x); // 6 (increment first, then use)
                    System.out.println(x++); // 6 (use first, then increment)

            (F) Conditional (Ternary) Operator
                Shorthand for if-else.

                Syntax:
                    condition ? expression1 : expression2;

                Example:
                    int age = 18;
                    String result = (age >= 18) ? "Adult" : "Minor";
                    System.out.println(result);  // Adult

            (G) Bitwise Operators
                Work at the bit-level (0s and 1s).

                | Operator | Meaning     | Example       |     |         |
                | -------- | ----------- | ------------- | --- | ------- |
                | `&`      | Bitwise AND | `5 & 3 = 1`   |     |         |
                | \`       | \`          | Bitwise OR    | \`5 | 3 = 7\` |
                | `^`      | Bitwise XOR | `5 ^ 3 = 6`   |     |         |
                | `~`      | Bitwise NOT | `~5 = -6`     |     |         |
                | `<<`     | Left Shift  | `5 << 1 = 10` |     |         |
                | `>>`     | Right Shift | `5 >> 1 = 2`  |     |         |

            (H) Miscellaneous Operators
                - instanceof → checks object type.
                - new → creates objects.
                - [] → array access.

        -> Operator Precedence and Associativity
            When multiple operators appear in a single expression, precedence and associativity decide the order of execution.

            - Precedence: Priority of operator.
            - Associativity: Direction of execution (left → right OR right → left).

            Operator Precedence Table (Java – simplified)
            | Precedence (High → Low) | Operators            | Associativity |    |               |
            | ----------------------- | -------------------- | ------------- | -- | ------------- |
            | 1                       | `++`, `--`, `!`, `~` | Right to Left |    |               |
            | 2                       | `*`, `/`, `%`        | Left to Right |    |               |
            | 3                       | `+`, `-`             | Left to Right |    |               |
            | 4                       | `<`, `>`, `<=`, `>=` | Left to Right |    |               |
            | 5                       | `==`, `!=`           | Left to Right |    |               |
            | 6                       | `&&`                 | Left to Right |    |               |
            | 7                       | \`                   |               | \` | Left to Right |
            | 8                       | `?:` (ternary)       | Right to Left |    |               |
            | 9                       | `=`, `+=`, `-=`      | Right to Left |    |               |

        -> Expression Evaluation
            Steps for Evaluating Expressions:
                - Check operator precedence.
                - If same precedence, check associativity.
                - Evaluate step by step.

            Example 1
                int result = 10 + 5 * 2;
                System.out.println(result);

                Evaluation:
                    - * has higher precedence → 5 * 2 = 10
                    - 10 + 10 = 20
                Output = 20

            Example 2 (With Increment)
                int a = 5, b = 2;
                int result = a++ * ++b;
                System.out.println(result);

                Step-by-step:
                    - a++ → use 5, then a becomes 6.
                    - ++b → increment first, so b = 3.
                    - 5 * 3 = 15.
                Output = 15

            Example 3 (Bank Discount System – Real Life)
                double bill = 1200;
                double discount = (bill > 1000) ? 0.10 : 0.05;
                double finalAmount = bill - (bill * discount);
                System.out.println("Payable: " + finalAmount);

                Output:
                    Payable: 1080.0

        -> Summary
            - Operators: Symbols to perform operations.
            - Types: Arithmetic, Relational, Logical, Assignment, Unary, Ternary, Bitwise.
            - Precedence: Defines which operator is executed first.
            - Associativity: Defines execution direction (L→R / R→L).
            - Expression Evaluation: Follows precedence + associativity rules.


    1.3 Control Flow Statements

        -> Introduction
            Control Flow Statements are used to control the order of execution of statements in a program.
            They allow us to make decisions, repeat tasks, or jump to another part of the program.

            Without control flow, programs would execute line by line from top to bottom only.
            With control flow, we can:
                - Choose (Decision making)
                - Repeat (Looping)
                - Jump (Transfer control)

        -> Types of Control Flow Statements

            There are mainly three categories:
                - Decision-Making Statements (Branching)
                - Looping Statements (Iteration)
                - Jump Statements (Transfer control)

            (A) Decision-Making Statements

                1. if Statement
                    Executes a block of code if a condition is true.

                    Syntax:
                        if (condition) {
                        // statements
                        }

                    Example:
                        int age = 18;
                        if (age >= 18) {
                            System.out.println("Eligible to vote");
                        }

                2. if-else Statement
                    Executes one block if condition is true, otherwise another block.

                    Syntax:
                        if (condition) {
                        // if block
                        } else {
                        // else block
                        }

                    Example:
                        int marks = 40;
                        if (marks >= 35) {
                            System.out.println("Pass");
                        } else {
                            System.out.println("Fail");
                        }

                3. Nested if Statement
                    if inside another if.

                    int marks = 85;
                    if (marks >= 35) {
                        if (marks >= 75) {
                            System.out.println("Distinction");
                        } else {
                            System.out.println("Pass");
                        }
                    } else {
                        System.out.println("Fail");
                    }

                4. if-else if Ladder
                    Used when multiple conditions are checked.

                    Example:
                        int marks = 65;
                        if (marks >= 75) {
                            System.out.println("Distinction");
                        } else if (marks >= 60) {
                            System.out.println("First Class");
                        } else if (marks >= 35) {
                            System.out.println("Pass");
                        } else {
                            System.out.println("Fail");
                        }

                5. switch Statement
                    Used when you want to compare one variable against multiple values.

                    Syntax:
                        switch (variable) {
                        case value1: statements; break;
                        case value2: statements; break;
                        ...
                        default: statements;
                        }

                    Example:
                        int day = 3;
                        switch (day) {
                            case 1: System.out.println("Monday"); break;
                            case 2: System.out.println("Tuesday"); break;
                            case 3: System.out.println("Wednesday"); break;
                            default: System.out.println("Invalid Day");
                        }

            (B) Looping Statements (Iteration)
                Used when we need to repeat a block of code multiple times.

                1. for Loop
                    Syntax:
                        for(initialization; condition; increment/decrement) {
                        // statements
                        }

                    Example:
                        for (int i = 1; i <= 5; i++) {
                            System.out.println("Hello " + i);
                        }

                2. while Loop
                    Used when the number of iterations is not fixed.

                    Syntax:
                        while (condition) {
                        // statements
                        }
                    
                    Example:
                        int i = 1;
                        while (i <= 5) {
                            System.out.println("Hello " + i);
                            i++;
                        }

                3. do-while Loop
                    Executes at least once (condition checked later).

                    Syntax:
                        do {
                        // statements
                        } while(condition);

                    Example:
                        int i = 1;
                        do {
                            System.out.println("Hello " + i);
                            i++;
                        } while (i <= 5);

                4. for-each Loop (Enhanced for)
                    Used to iterate arrays/collections.

                    Example:
                        int arr[] = {10, 20, 30};
                        for (int num : arr) {
                            System.out.println(num);
                        }

            (C) Jump Statements
                Used to transfer control from one part of the program to another.

                1. break
                    Terminates loop/switch immediately.

                    Example:
                        for (int i = 1; i <= 5; i++) {
                            if (i == 3) break;
                            System.out.println(i);
                        }
                    Output: 1 2

                2. continue
                    Skips the current iteration and moves to the next one.

                    Example:
                        for (int i = 1; i <= 5; i++) {
                            if (i == 3) continue;
                            System.out.println(i);
                        }
                    Output: 1 2 4 5

                3. return
                    Exits from a method and optionally returns a value.

                    Example:
                        public int square(int n) {
                            return n * n;
                        }

        -> Real-Life Example (Bank ATM System)
            int choice = 2;
            switch(choice) {
                case 1: System.out.println("Check Balance"); break;
                case 2: System.out.println("Withdraw Money"); break;
                case 3: System.out.println("Deposit Money"); break;
                default: System.out.println("Invalid Choice");
            }
            Works like an ATM menu – control flows to the selected option.

        -> Diagram for Exam
            Types of Control Flow Statements

                            Control Flow
                            |
            ---------------------------------
            |               |               |
            Decision        Looping         Jump
            (if, else,      (for, while,    (break,
            switch)         do-while)       continue, return)

        -> Summary
            - Decision-making → if, if-else, switch.
            - Looping → for, while, do-while, for-each.
            - Jump → break, continue, return.
            - They make programs flexible, efficient, and intelligent.


    1.4 Object Oriented Programming: Ovrview, Use case, Features and Advantages


        -> Overview

            Definition:
                Object-Oriented Programming (OOP) is a programming paradigm based on the concept of objects that contain data (attributes) and methods (functions) to operate on that data.
            
            In OOP, objects represent real-world entities like student, car, bank account.
            It is different from Procedure-Oriented Programming (POP), where the focus is on functions instead of objects.

            Real Life Analogy:

                Think of a Car as an object:
                    - Attributes (Data) → color, brand, speed.
                    -Methods (Functions) → start(), stop(), accelerate().

        -> Use Case of OOP
            OOP is widely used in real-life applications where modularity, security, and reusability are important.

            Examples:
                Banking System
                    Object: Account
                    Attributes: accountNo, balance
                    Methods: deposit(), withdraw(), checkBalance()

                E-commerce Application (like Amazon/Flipkart)
                    Objects: Product, Customer, Order
                    Each has attributes (price, name, ID) and methods (buy(), addToCart()).

                Hospital Management System
                    Objects: Doctor, Patient, Appointment.

        -> Features of OOP
            OOP provides four main pillars (core features) + some additional features.

            (A) Core Features
                1. Encapsulation

                    Wrapping of data and methods into a single unit (class).
                    Protects data from outside interference.

                    Example (Java):
                        class Student {
                            private int marks;  // data hiding

                            public void setMarks(int m) {   // setter
                                marks = m;
                            }

                            public int getMarks() {         // getter
                                return marks;
                            }
                        }

                    Marks are accessed only through methods → security.

                2. Abstraction

                    Showing only essential features and hiding internal details.
                    Example: When you drive a car, you use steering and brakes, but you don’t know the engine’s internal working.

                    Example (Java):
                        abstract class Vehicle {
                            abstract void start();
                        }

                        class Car extends Vehicle {
                            void start() {
                                System.out.println("Car starts with a key");
                            }
                        }

                3. Inheritance

                    One class acquires properties & behavior of another class.
                    Promotes reusability.

                    Example (Java):
                        class Animal {
                            void eat() { System.out.println("Eating"); }
                        }

                        class Dog extends Animal {
                            void bark() { System.out.println("Barking"); }
                        }

                    Dog inherits eat() from Animal.

                4. Polymorphism

                    Means one name, many forms.
                    Two types:
                        - Compile-time (Method Overloading)
                        - Runtime (Method Overriding)

                    Example (Overloading):
                        class MathCalc {
                            int add(int a, int b) { return a + b; }
                            double add(double a, double b) { return a + b; }
                        }

                    Example (Overriding):
                        class Animal {
                            void sound() { System.out.println("Animal sound"); }
                        }

                        class Dog extends Animal {
                            void sound() { System.out.println("Bark"); }
                        }

            (B) Additional Features
                Class and Object → Base concept of OOP.
                Data Hiding → Achieved using private access modifier.
                Code Reusability → Write once, use multiple times.
                Modularity → Code is divided into smaller parts (classes).

        -> Advantages of OOP

            Why OOP is better than traditional approaches:
                Reusability – Code can be reused using inheritance.
                Modularity – Complex problems broken into objects.
                Data Security – Encapsulation hides sensitive data.
                Flexibility – Polymorphism makes it flexible.
                Maintainability – Easy to debug and update.
                Scalability – Best for large-scale applications.
                Real-world mapping – Objects in code resemble real-world entities.

        -> Diagram (For Exam)
            OOP Pillars

                    Object Oriented Programming
                                |
                -------------------------------------------
                |      |        |          |              |
            Encapsulation  Abstraction  Inheritance  Polymorphism

        -> Real-Life Example (Bank Account System)

            class Account {
                private double balance; // Encapsulation

                public void deposit(double amount) {
                    balance += amount;
                }

                public void withdraw(double amount) {
                    if(balance >= amount)
                        balance -= amount;
                }

                public double getBalance() {
                    return balance;
                }
            }

            class SavingsAccount extends Account {  // Inheritance
                double interestRate = 0.05;

                public void addInterest() {
                    deposit(getBalance() * interestRate); // Polymorphism (method reuse)
                }
            }

            Here:
                Encapsulation: Balance is private.
                Inheritance: SavingsAccount inherits from Account.
                Polymorphism: deposit() used in multiple ways.
                Abstraction: User doesn’t know internal working, just uses deposit/withdraw methods.

        -> Summary

            - Overview: OOP → object-based programming paradigm.
            - Use Cases: Banking, E-commerce, Hospital, etc.
            - Features: Encapsulation, Abstraction, Inheritance, Polymorphism.
            - Advantages: Security, Reusability, Modularity, Scalability.

















