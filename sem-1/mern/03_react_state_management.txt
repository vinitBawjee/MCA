3. React State Management


    3.1 Async State Initialization

        -> Introduction

            React mein state ka matlab hota hai ek dynamic data storage jo component ke andar change ho sakta hai aur component automatically re-render hota hai.

            Async State Initialization ka matlab hai:
                - State ko turant nahi set kar rahe, balki async operations ke baad set kar rahe hain.
                - Example: API call, localStorage, database se data fetch karna.

        -> Why Async State Initialization?

            - Sometimes component load hote hi hume server ya database se data fetch karna hota hai.
            - Direct useState(initialValue) me ye possible nahi kyunki async operations promise return karte hain.
            - Solution → useEffect + state initialization after async call.

        -> Syntax & Example

            Scenario: User Profile fetch karna API se

                import React, { useState, useEffect } from "react";

                function UserProfile() {
                    const [user, setUser] = useState(null); // initial state null

                    useEffect(() => {
                        // async function to fetch data
                        async function fetchUser() {
                            const response = await fetch("https://api.example.com/user/1");
                            const data = await response.json();
                            setUser(data); // state updated after async fetch
                        }

                        fetchUser();
                    }, []); // empty dependency → runs once on mount

                    if (!user) {
                        return <p>Loading user data...</p>; // render while waiting
                    }

                    return (
                        <div>
                            <h2>{user.name}</h2>
                            <p>Email: {user.email}</p>
                        </div>
                    );
                }

                export default UserProfile;

            Step by Step Explanation
                (1) useState(null) → initial state null rakhte hain kyunki data abhi nahi aya.
                (2) useEffect() → component mount hote hi async function call karte hain.
                (3) fetchUser() → async call jo server se user data fetch karta hai.
                (4) setUser(data) → async response ke baad state update.
                (5) Component automatically re-render hoga aur new data show karega.

        -> Real-Life Example

            Socho tumhari Online Auction Website hai:
                - Jab Seller login karta hai, Dashboard pe total auctions, earnings aur completed orders fetch karne hai.
                - Ye data server pe stored hai → async fetch ke baad state update karna padega.

                    const [stats, setStats] = useState(null);

                    useEffect(() => {
                        async function fetchStats() {
                            const res = await fetch("/api/seller/stats");
                            const data = await res.json();
                            setStats(data);
                        }
                        fetchStats();
                    }, []);
                
                - Jab tak data load ho raha hai, user ko "Loading..." message show kar sakte ho.
                - Data aate hi dashboard update ho jata hai automatically.

        -> Notes / Best Practices

            (1) Initial state null ya empty array/object rakhna safe hota hai.
            (2) Async state update hamesha useEffect ke andar karna.
            (3) Loading state dikhana UX ke liye important hai.
            (4) Error handling ke liye try/catch use kar sakte ho.

        -> Conclusion

            - React mein state dynamically update hota hai.
            - Async State Initialization zaroori hai jab API / DB / localStorage se data fetch karna ho.
            - useState + useEffect combination is ka best practice hai.
            - Real-life: Dashboard stats, user profile, product list fetch karna SPA mein.


    3.2 Hooks: useState and useEffect

        -> Introduction

            React Hooks ek special feature hai jo functional components me state aur lifecycle methods allow karta hai.
                - Hooks se hum class components ki complexity se bach sakte hain.
                - Most common hooks: useState (state management) aur useEffect (side-effects / lifecycle methods).

        -> useState

            - useState ek function hai jo component ke state ko create aur update karta hai.
            - Ye hamesha functional component me use hota hai.

            Syntax:
                import React, { useState } from "react";

                function Counter() {
                const [count, setCount] = useState(0); // initial value 0

                return (
                    <div>
                    <h2>Count: {count}</h2>
                    <button onClick={() => setCount(count + 1)}>Increment</button>
                    </div>
                );
                }

            Explanation:
                (1) count → current state value.
                (2) setCount → function to update state.
                (3) useState(0) → initial value 0.
                (4) Button click → setCount(count + 1) → state update → component re-render.

        -> useEffect

            - useEffect ek hook hai jo side                        
                        async function fetchStats() {
                            const res = await fetch("/api/seller/stats");
                            const data = await res.json();
                            setStats(data);
                        }
                        fetchStats(); 
            - effects handle karta hai, jaise:
                - API calls
                - DOM updates
                - vent listeners
                - Timer

            - Ye lifecycle methods (componentDidMount, componentDidUpdate, componentWillUnmount) ka functional alternative hai.

            Syntax:
                import React, { useState, useEffect } from "react";

                function Timer() {
                const [seconds, setSeconds] = useState(0);

                useEffect(() => {
                    const interval = setInterval(() => {
                    setSeconds(prev => prev + 1); // state update
                    }, 1000);

                    return () => clearInterval(interval); // cleanup on unmount
                }, []); // empty dependency → run once on mount

                return <h2>Seconds: {seconds}</h2>;
                }

            Explanation:
                (1) useEffect me jo function hai → component mount hone ke baad run hota hai.
                (2) setInterval → state update har second.
                (3) return () => clearInterval(interval) → cleanup, memory leak avoid karne ke liye.
                (4) [] dependency → sirf ek baar run on mount.

        -> Real-Life Example

            Scenario: Auction Website – Fetch Live Bids

                function LiveBids({ auctionId }) {
                const [bids, setBids] = useState([]);

                useEffect(() => {
                    async function fetchBids() {
                    const res = await fetch(`/api/auction/${auctionId}/bids`);
                    const data = await res.json();
                    setBids(data);
                    }

                    fetchBids();
                    const interval = setInterval(fetchBids, 5000); // update every 5 seconds

                    return () => clearInterval(interval); // cleanup
                }, [auctionId]);

                return (
                    <div>
                    <h3>Live Bids</h3>
                    <ul>
                        {bids.map(bid => (
                        <li key={bid.id}>{bid.user}: ₹{bid.amount}</li>
                        ))}
                    </ul>
                    </div>
                );
                }

            Explanation:
                (1) useState([]) → bids array initial state.
                (2) useEffect → data fetch on mount + repeat every 5 sec.
                (3) Cleanup → stop interval on component unmount.
                (4) Result → UI auto-update hota hai without full page reload.

        -> Key Points

            (1) useState → simple, state management for functional components.
            (2) useEffect → replace class lifecycle methods, handle side-effects.
            (3) Dependency array → control re-render / effect execution.
            (4) Cleanup function → avoid memory leaks.
            (5) Real-life: Live bids, notifications, API data fetch, timers.

        -> Conclusion

            - Hooks se functional components powerful ban gaye.
            - useState + useEffect → SPA ke dynamic aur interactive behavior ka backbone.
            - Real-life applications: Auction stats, live bidding, chat messages, dashboards.


    3.3 Event Handling

        -> Introduction

            React me Event Handling ka matlab hai:
                - Users ke actions ko handle karna jaise:
                    - Click
                    - Input change
                    - Submit
                    - Mouse hover

                - React events ka syntax DOM ke traditional events se thoda different hota hai.

        -> Key Points

            (1) CamelCase convention use hoti hai (e.g., onClick instead of onclick).
            (2) Event handler function ko curly braces {} me pass karte hain.
            (3) Class Components me this binding important hota hai.
            (4) Functional Components me simple arrow function ya normal function use karte hain.

        -> Syntax – Functional Component
            import React, { useState } from "react";

            function ClickCounter() {
                const [count, setCount] = useState(0);

                function handleClick() {
                    setCount(count + 1);
                }

                return (
                    <div>
                    <h2>Count: {count}</h2>
                    <button onClick={handleClick}>Click Me</button>
                    </div>
                );
            }

            Explanation:
                - onClick={handleClick} → button click hone par function call hota hai.
                - setCount(count + 1) → state update → component re-render.

        -> Syntax – Inline Arrow Function

            <button onClick={() => setCount(count + 1)}>Click Me</button>

            - Ye short form hai.
            - Useful agar function simple hai aur arguments pass karne hai.

        -> Event Handling with Parameters

            function Greet(name) {
                alert("Hello " + name);
            }

            <button onClick={() => Greet("Bunty")}>Greet Me</button>

            - Agar direct onClick={Greet("Bunty")} likhoge → function immediately call ho jayega.
            - Isliye arrow function wrap karte hain.

        -> Real-Life Example

            Scenario: Auction Website – Place Bid Button

                function PlaceBid({ auctionId, currentUser }) {
                const handleBid = (amount) => {
                    console.log(`User ${currentUser} placed a bid of ₹${amount} on auction ${auctionId}`);
                    // API call to place bid
                };

                return (
                    <div>
                    <button onClick={() => handleBid(5000)}>Bid ₹5000</button>
                    <button onClick={() => handleBid(10000)}>Bid ₹10000</button>
                    </div>
                );
                }

            Explanation:
                - Button click → handleBid() call → console/API update.
                - Users easily different bids place kar sakte hain.

        -> Synthetic Event

            - React me sabhi events SyntheticEvent object ke through pass hote hain.
            - Ye browser compatibility handle karta hai.

                function handleInputChange(e) {
                    console.log(e.target.value);
                }

                <input type="text" onChange={handleInputChange} />

            - e.target.value → current input value.

        -> Conclusion

            - React me events camelCase me hote hain.
            - Functional components me simple functions + arrow functions use hoti hain.
            - Real-life use: Buttons, forms, input fields, auctions bids, notifications, etc.
            - SyntheticEvent → browser compatibility aur consistent behavior.


    3.4 Forms in React    

        -> Introduction

            React me forms ka use hota hai user input lene ke liye, jaise:
                - Text input
                - Radio/checkbox
                - Select dropdown
                - File upload

            Key point:
                - React me forms controlled ya uncontrolled ho sakte hain.
                - Controlled form → input ka value React state se control hota hai.
                - Uncontrolled form → input ka value DOM se directly read hota hai.

        -> Controlled Components

            - Sabse zyada use hota hai.
            - State ke through input value ko track karte hain.

            Syntax:
                import React, { useState } from "react";

                function LoginForm() {
                const [email, setEmail] = useState("");
                const [password, setPassword] = useState("");

                const handleSubmit = (e) => {
                    e.preventDefault(); // page reload avoid
                    console.log("Email:", email);
                    console.log("Password:", password);
                };

                return (
                    <form onSubmit={handleSubmit}>
                    <input
                        type="email"
                        value={email}
                        onChange={(e) => setEmail(e.target.value)}
                        placeholder="Enter email"
                    />
                    <input
                        type="password"
                        value={password}
                        onChange={(e) => setPassword(e.target.value)}
                        placeholder="Enter password"
                    />
                    <button type="submit">Login</button>
                    </form>
                );
                }

            Explanation:
                (1) value={email} → input field React state se control hota hai.
                (2) onChange={(e) => setEmail(e.target.value)} → user input ke saath state update hoti hai.
                (3) handleSubmit(e) → form submit hone par page reload prevent hota hai aur state data console ya API me send hota hai.

        -> Multiple Inputs with Single State

            const [formData, setFormData] = useState({ username: "", email: "" });

            const handleChange = (e) => {
                setFormData({ ...formData, [e.target.name]: e.target.value });
            };

            <form onSubmit={handleSubmit}>
                <input
                    name="username"
                    value={formData.username}
                    onChange={handleChange}
                />
                <input
                    name="email"
                    value={formData.email}
                    onChange={handleChange}
                />
                <button type="submit">Submit</button>
            </form>

            - Single formData state se multiple inputs control hote hain.
            - Spread operator ...formData → previous state maintain kare.

        -> Real-Life Example
            Scenario: Auction Website – Add New Auction Form

            function AddAuction() {
                const [auction, setAuction] = useState({
                title: "",
                startPrice: "",
                category: ""
                });

                const handleChange = (e) => {
                    setAuction({ ...auction, [e.target.name]: e.target.value });
                };

                const handleSubmit = (e) => {
                    e.preventDefault();
                    console.log("New Auction:", auction);
                    // API call to save auction
                };

                return (
                    <form onSubmit={handleSubmit}>
                        <input
                        name="title"
                        value={auction.title}
                        onChange={handleChange}
                        placeholder="Auction Title"
                        />
                        <input
                        name="startPrice"
                        value={auction.startPrice}
                        onChange={handleChange}
                        placeholder="Starting Price"
                        />
                        <select name="category" value={auction.category} onChange={handleChange}>
                        <option value="">Select Category</option>
                        <option value="Electronics">Electronics</option>
                        <option value="Art">Art</option>
                        </select>
                        <button type="submit">Add Auction</button>
                    </form>
                );
            }

            Explanation:
                (1) auction state → store all input values.
                (2) handleChange → dynamically update specific field.
                (3) handleSubmit → prevent default, send data to backend/API.
                (4) Users easily new auction create kar sakte hain without page reload.

        -> Uncontrolled Components

            - React state se input control nahi hota.
            - Instead, ref use karke value read karte hain.

            import { useRef } from "react";

            function UncontrolledForm() {
                const inputRef = useRef();

                const handleSubmit = (e) => {
                    e.preventDefault();
                    console.log("Input Value:", inputRef.current.value);
                };

                return (
                    <form onSubmit={handleSubmit}>
                    <input type="text" ref={inputRef} />
                    <button type="submit">Submit</button>
                    </form>
                );
            }

            Note: Controlled components recommended for most cases.

        -> Key Points

            (1) Controlled components → state drives the input value.
            (2) Uncontrolled components → DOM drives the input value (ref).
            (3) onChange → update state on user input.
            (4) onSubmit → prevent default page reload.
            (5) Real-life: Login forms, auction submission, profile edit, search box.

        -> Conclusion

            - Forms in React dynamic aur reactive hote hain.
            - useState aur onChange → main tool to control input.
            - Real-life: SPA websites me form submission smooth aur fast hoti hai, without reload.

        ab React State Management chapter ke 4 main topics complete ho gaye:
            (1) Async State Initialization
            (2) Hooks: useState & useEffect
            (3) Event Handling
            (4) Forms in React


    3.5 Context API

        -> Introduction

            React me Context API ka use hota hai state/data ko deeply nested components me pass karne ke liye bina props drilling ke.
                - Props drilling → parent → child → grandchild … har level pe props pass karna.
                - Context API → ek global state jaisa kaam karta hai, jise koi bhi child directly access kar sakta hai.

        -> Why Context API?

            Problem Example (Props Drilling):

                function App() {
                    const user = { name: "Bunty", role: "Seller" };
                    return <Dashboard user={user} />;
                }

                function Dashboard({ user }) {
                    return <Profile user={user} />;
                }

                function Profile({ user }) {
                    return <h2>Welcome, {user.name}</h2>;
                }

            - user har level pe pass karna pada → messy code.
            - Solution → Context API

        -> Syntax – Creating Context

            import React, { createContext, useContext } from "react";

            // 1. Create Context
            const UserContext = createContext();

            // 2. Provider Component
            function App() {
            const user = { name: "Bunty", role: "Seller" };

            return (
                <UserContext.Provider value={user}>
                <Dashboard />
                </UserContext.Provider>
            );
            }

            // 3. Consume Context in deeply nested component
            function Profile() {
            const user = useContext(UserContext); // access context directly
            return <h2>Welcome, {user.name} ({user.role})</h2>;
            }

            // Dashboard just renders Profile, no props needed
            function Dashboard() {
            return <Profile />;
            }

            Explanation:
                - createContext() → ek new context object create karta hai.
                - Provider → context ka value provide karta hai subtree me.
                - useContext(UserContext) → child component me context value access karne ke liye.

        -> Real-Life Example

            Scenario: Auction Website – Logged-in User Info
                - Global User Info: name, role, balance
                - Multiple components (Navbar, Dashboard, AuctionList, Profile) me access chahiye.

            const UserContext = createContext();

            function App() {
                const user = { name: "Bunty", role: "Seller", balance: 50000 };

                return (
                    <UserContext.Provider value={user}>
                    <Navbar />
                    <Dashboard />
                    </UserContext.Provider>
                );
            }

            function Navbar() {
                const user = useContext(UserContext);
                return <p>Hello, {user.name} | Balance: ₹{user.balance}</p>;
            }

            function Dashboard() {
                const user = useContext(UserContext);
                return <h2>Role: {user.role}</h2>;
            }

            Benefit:
                - Props drilling nahi karna padta.
                - Global data har child component me easily accessible.

        -> Notes / Best Practices

            (1) Context API best for global/shared state (theme, auth, language, user).
            (2) Frequent updates in large context → performance issues (re-rendering).
            (3) For local state → continue using useState inside component.
            (4) Combine with useReducer → complex global state manage karne ke liye.

        -> Conclusion

            - Context API → React ka built-in feature for global state.
            - Remove props drilling → cleaner, maintainable code.
            - Real-life:
                - Logged-in user info
                - Theme (light/dark)
                - Language preferences
                - Cart info in e-commerce SPA

                